window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "microns_datacleaner", "modulename": "microns_datacleaner", "kind": "module", "doc": "<h1 id=\"microns-datacleaner-docs\">MICrONS DataCleaner Docs</h1>\n\n<p>This webpage contains all the documentation for the <a href=\"https://github.com/margheritapremi/MICrONS-datacleaner\">MICrONS DataCleaner</a> pakcage. </p>\n\n<h2 id=\"install\">Install \ud83d\udce5</h2>\n\n<p>You can install the package from PyPi via </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">pip</span> <span class=\"n\">install</span> <span class=\"n\">microns</span><span class=\"o\">-</span><span class=\"n\">datacleaner</span>\n</code></pre>\n</div>\n\n<h2 id=\"quick-start\">Quick Start \u23e9</h2>\n\n<p>For more detailed code, you can also check out the <code>basic_tutorial.ipynb</code> notebook inside <code>tutorial</code>.</p>\n\n<h3 id=\"download-nucleus-information\">Download nucleus information</h3>\n\n<p>The package is initiated by importing and generating an instance of the class, where you specify the <code>datadir</code> folder (where data will be downloaded), the <code>version</code> of the data you intend to download (see the <a href=\"https://www.microns-explorer.org/manifests\">data releases</a>).</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\">#Import the lib</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">microns_datacleaner</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">mic</span>\n\n<span class=\"c1\">#Target version and download folder</span>\n<span class=\"n\">cleaner</span> <span class=\"o\">=</span> <span class=\"n\">mic</span><span class=\"o\">.</span><span class=\"n\">MicronsDataCleaner</span><span class=\"p\">(</span><span class=\"n\">datadir</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;data&quot;</span><span class=\"p\">,</span> <span class=\"n\">version</span><span class=\"o\">=</span><span class=\"mi\">1300</span><span class=\"p\">,</span> <span class=\"n\">download_policy</span><span class=\"o\">=</span><span class=\"s1\">&#39;minimum&#39;</span><span class=\"p\">)</span> \n\n<span class=\"c1\">#Download the data</span>\n<span class=\"n\">cleaner</span><span class=\"o\">.</span><span class=\"n\">download_nucleus_data</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n\n<p>The <code>download_policy</code> stablishes which tables to be downloaded (see API below for details). The default mode, <code>minimum</code>, downloads only the tables which are required to build the unit table generated by the package.</p>\n\n<p>The tables needs to be downloaded <strong>only once</strong>. They will be downloaded in <code>datadir/version/raw</code>. In this way, if you change the <code>version</code>, the tables will not be mixed, allowing for more replicable analyses.</p>\n\n<p>Once the data is downloaded, the unit table can be constructed as </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">units</span><span class=\"p\">,</span> <span class=\"n\">segments</span> <span class=\"o\">=</span> <span class=\"n\">cleaner</span><span class=\"o\">.</span><span class=\"n\">process_nucleus_data</span><span class=\"p\">(</span><span class=\"n\">functional_data</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>The <code>segments</code> variable is a table with the resulting segmentation of the layers. The <code>units</code> includes all the information about the units. The package includes the information for all AIBS classified units. The position is already transformed into pial coordinates, with Y being the depth. Observe that the table includes also nonneuronal objects.</p>\n\n<p>The raw dataset contains objects with duplicated <code>pt_root_id</code>, that can be overmerged objects, including fraction of an axon, spine head, or multisoma object. For this reason, the package works always with the <code>nucleus_id</code> when merging the tables. All objects that present more than <code>pt_root_id</code> are eliminated: it is not that _the duplicates_ are eliminates, but _all the objects_ that presented a duplicate. The <code>units</code> variable has unique <code>nucleus_id</code> and <code>pt_root_id</code>.</p>\n\n<p>The flag <code>functional_data</code> allows for several options to integrate information from the functional dataset (see details in the API). In particular, it can add manually coregistrated <code>session</code>, <code>scan_idx</code> and <code>unit_id</code> in order to match the connectomics with the functional data. </p>\n\n<p>Finally, you might want to merge some information in the unit table that is not present but can be found in other annotation tables. The available tables can be easily obtained and downloaded with</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">cleaner</span><span class=\"o\">.</span><span class=\"n\">get_table_list</span><span class=\"p\">()</span>\n\n<span class=\"c1\">#Example download of the automatic coregistration</span>\n<span class=\"n\">cleaner</span><span class=\"o\">.</span><span class=\"n\">download_tables</span><span class=\"p\">([</span><span class=\"s1\">&#39;coregistration_auto_phase3_fwd_apl_vess_combined_v2&#39;</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n\n<p>The tables can be easily merged with the unit table using the convenience function <code>merge_columns</code>. Please refer to the <code>basic_tutorial</code> notebook for more examples.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">auto_coreg</span> <span class=\"o\">=</span> <span class=\"n\">cleaner</span><span class=\"o\">.</span><span class=\"n\">read_table</span><span class=\"p\">(</span><span class=\"s2\">&quot;coregistration_auto_phase3_fwd_apl_vess_combined_v2&quot;</span><span class=\"p\">)</span>\n\n<span class=\"c1\">#Add the columns from the auto_coreg table to our unit table</span>\n<span class=\"n\">units</span> <span class=\"o\">=</span> <span class=\"n\">cleaner</span><span class=\"o\">.</span><span class=\"n\">merge_table</span><span class=\"p\">(</span><span class=\"n\">units</span><span class=\"p\">,</span> <span class=\"n\">auto_coreg</span><span class=\"p\">,</span> <span class=\"n\">columns</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">&#39;session&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;scan_idx&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;unit_id&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;score&#39;</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n\n<h3 id=\"download-synapses\">Download synapses</h3>\n\n<p>The synapse table is too large to be downloaded entirely. For this reason, one needs to query the dataset with the desired subset of pre and post-synaptic neurons. This can be done only by specifying the <code>pt_root_id</code> of the desired units. One these have been selected, the synapses can be downloaded with    </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\">#All presynaptic inputs to a random sample of units </span>\n<span class=\"n\">postids</span> <span class=\"o\">=</span> <span class=\"n\">units</span><span class=\"p\">[</span><span class=\"s1\">&#39;pt_root_id&#39;</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">sample</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">50</span><span class=\"p\">)</span>\n<span class=\"n\">preids</span>  <span class=\"o\">=</span> <span class=\"n\">units</span><span class=\"p\">[</span><span class=\"s1\">&#39;pt_root_id&#39;</span><span class=\"p\">]</span>\n<span class=\"n\">cleaner</span><span class=\"o\">.</span><span class=\"n\">download_synapse_data</span><span class=\"p\">(</span><span class=\"n\">preids</span><span class=\"p\">,</span> <span class=\"n\">postids</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>The <code>download_synapse_data</code> function allows to download the data in chunks of neurons of predefined size. In this way, if the server connection fails, part of the data was already written to file and download can re-start from where it was left. If a problem occurs, the function will retry automatically. Parameters such as the maximum number of trials before giving up, time between trials or download chunk size can be set. </p>\n\n<p>By default, <code>download_synapse_data</code> collapses all synapses between two units to a single effective connection. The synaptic size is the sum all of synapses found between the two units. By setting <code>drop_synapses_duplicates = False</code> one can retrieve all the individual synapses, as well as their position.  </p>\n\n<p>Once all the chunks have been loaded, they need to be manually merged, indicating the name of the desired synapse table. </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">cleaner</span><span class=\"o\">.</span><span class=\"n\">merge_synapses</span><span class=\"p\">(</span><span class=\"n\">syn_table_name</span><span class=\"o\">=</span><span class=\"s2\">&quot;example_merged_synapses&quot;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<h3 id=\"filtering\">Filtering</h3>\n\n<p>The package includes a submodule <code>mic_datacleaner.filters</code> in order to easily query the constructed unit and connections tables. The function <code>fl.filter_neurons</code> can be used to subset neurons by several conditions at the same time:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\">#All neurons that (1) are in area V1 (2) have proofread axons (3) are either in L2/3 or L4 </span>\n<span class=\"n\">units_filter</span> <span class=\"o\">=</span> <span class=\"n\">fl</span><span class=\"o\">.</span><span class=\"n\">filter_neurons</span><span class=\"p\">(</span><span class=\"n\">units</span><span class=\"p\">,</span> <span class=\"n\">layer</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">&#39;L2/3&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;L4&#39;</span><span class=\"p\">],</span> <span class=\"n\">proofread</span><span class=\"o\">=</span><span class=\"s1\">&#39;ax_clean&#39;</span><span class=\"p\">,</span> <span class=\"n\">brain_area</span><span class=\"o\">=</span><span class=\"s1\">&#39;V1&#39;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>More examples can be found on the <code>basic_tutorial</code> notebook. The synapses can be also filtered, </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\">#All synapses with </span>\n<span class=\"c1\"># - presynaptic neurons in V1 with axons clean</span>\n<span class=\"c1\"># - postsynaptic neurons in either RL, AL or LM</span>\n<span class=\"n\">syn_filter</span> <span class=\"o\">=</span> <span class=\"n\">fl</span><span class=\"o\">.</span><span class=\"n\">filter_connections</span><span class=\"p\">(</span><span class=\"n\">units</span><span class=\"p\">,</span> <span class=\"n\">synapses</span><span class=\"p\">,</span>  <span class=\"n\">brain_area</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">&#39;V1&#39;</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">&#39;RL&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;AL&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;LM&#39;</span><span class=\"p\">]],</span> <span class=\"n\">proofread</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">&#39;ax_clean&#39;</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">])</span> \n</code></pre>\n</div>\n\n<p>or just by directly indicating the ids of the pre and post synaptic neurons that we want </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">syn_filter</span> <span class=\"o\">=</span> <span class=\"n\">fl</span><span class=\"o\">.</span><span class=\"n\">synapses_by_id</span><span class=\"p\">(</span><span class=\"n\">units</span><span class=\"p\">,</span> <span class=\"n\">synapses</span><span class=\"p\">,</span> <span class=\"n\">pre_ids</span><span class=\"o\">=</span><span class=\"n\">units_filter</span><span class=\"p\">[</span><span class=\"s1\">&#39;pt_root_id&#39;</span><span class=\"p\">],</span> <span class=\"n\">post_ids</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span> \n</code></pre>\n</div>\n\n<p>Please read the API documentation for filters to find our more.</p>\n\n<h3 id=\"remapping\">Remapping</h3>\n\n<p>When working with functional data and tunign curves it is useful to obtain the rates as a matrix to efficiently compute currents. This needs a remapping of the <code>pt_root_id</code>. Please check out the <code>basic_tutorial</code> notebook or the <code>remapper</code> subpackage docs to find out more.</p>\n\n<h2 id=\"license-and-citation-policy\">License and citation policy \ud83d\udcda</h2>\n\n<p>The code is shared under a license. When using our package, please consider citing it appropiately.</p>\n\n<p>The data is downloaded from the <a href=\"https://www.microns-explorer.org/\">MICrONS Project</a> directly. Therefore, please follow also the <a href=\"https://www.microns-explorer.org/citation-policy\">license and citation policy of the MICrONS dataset</a>. </p>\n\n<p>The repositories from which the data is extracted are </p>\n\n<ol>\n<li><a href=\"https://doi.org/10.60533/BOSS-2021-T0SY\">IARPA MICrONS Minnie Project</a> </li>\n<li><a href=\"https://github.com/cajal/microns_phase3_nda\">Microns Phase 3 NDA</a>. </li>\n</ol>\n\n<p>To construct the tables the package downloads results derived from the following papers of the MICrONS collaboration: </p>\n\n<ol>\n<li><a href=\"https://doi.org/10.1038/s41586-025-08790-w\">Functional connectomics spanning multiple areas of mouse visual cortex</a>. The Microns Consortium. 2025 </li>\n<li><a href=\"https://doi.org/10.1038/s41586-025-08829-y\">Foundation model of neural activity predicts response to new stimulus types</a></li>\n<li><a href=\"http://doi.org/10.1038/s41586-024-07765-7\">Perisomatic ultrastructure efficiently classifies cells in mouse cortex</a></li>\n<li><a href=\"https://doi.org/\">NEURD offers automated proofreading and feature extraction for connectomics</a></li>\n<li><a href=\"https://doi.org/10.1038/s41592-024-02426-z\">CAVE: Connectome Annotation Versioning Engine</a></li>\n</ol>\n\n<h2 id=\"building-the-docs\">Building the docs \ud83d\udcdc</h2>\n\n<p>To generate these docs locally in your computer, you need <a href=\"https://pdoc.dev/\">pdoc</a>. Then, fromn the root directory of the repository, run</p>\n\n<pre><code>pdoc -t docs/template src/microns_datacleaner/ -o docs/html\n</code></pre>\n\n<p>The docs will be generated in the <code>docs/html</code> folder in HTML format, which can be checked with the browser. You can also get docs for individual just using <code>src/filename.py</code>.</p>\n"}, {"fullname": "microns_datacleaner.MicronsDataCleaner", "modulename": "microns_datacleaner", "qualname": "MicronsDataCleaner", "kind": "class", "doc": "<p>The main class to download and clean data from the Microns Dataset.</p>\n"}, {"fullname": "microns_datacleaner.MicronsDataCleaner.__init__", "modulename": "microns_datacleaner", "qualname": "MicronsDataCleaner.__init__", "kind": "function", "doc": "<p>Initialize the class and makes sure subfolders to download exist. Configures the tables to be downloaded (except synapses) via\na download policy.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>datadir: string, optional\n    Defaults to 'data'. Points to the folder where information will be downloaded.\ncustom_tables: dict, optional \n    Used to override the default tables used to construct the unit table in a given version. The keys for the tables\n    to be overrided are 'celltype' for the nucleus classification scheme, 'proofreading' for the prooreading table,\n    'brain_areas' for assigned brain areas, 'func_props' for functional properties, and 'coreg' for the coregistration table.\ndownload_policy: str, optional\n    Used to set how the tables should be downloaded. 'minimum' (the default) only downloads the minimum amount of tables necessary \n    to construct our unit table. 'all' gets all of them. 'extra' gets the same as 'minimum' plus the tables specified in `extra_tables`.\nextra_tables: list, optional\n    List of extra table names to be downloaded. See the download_police for more information.\n</code></pre>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>None.\n    This method is a constructor and does not return any value.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">datadir</span><span class=\"o\">=</span><span class=\"s1\">&#39;data&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">version</span><span class=\"o\">=</span><span class=\"mi\">1300</span>,</span><span class=\"param\">\t<span class=\"n\">download_policy</span><span class=\"o\">=</span><span class=\"s1\">&#39;minimum&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">extra_tables</span><span class=\"o\">=</span><span class=\"p\">[]</span></span>)</span>"}, {"fullname": "microns_datacleaner.MicronsDataCleaner.homedir", "modulename": "microns_datacleaner", "qualname": "MicronsDataCleaner.homedir", "kind": "variable", "doc": "<p>Subfolder aimed to contain the downloaded data</p>\n", "default_value": "PosixPath(&#x27;/home/victor/Fisica/Research/Milan/MICrONS-datacleaner&#x27;)"}, {"fullname": "microns_datacleaner.MicronsDataCleaner.datadir", "modulename": "microns_datacleaner", "qualname": "MicronsDataCleaner.datadir", "kind": "variable", "doc": "<p>Version of the client we are using</p>\n", "default_value": "&#x27;data&#x27;"}, {"fullname": "microns_datacleaner.MicronsDataCleaner.version", "modulename": "microns_datacleaner", "qualname": "MicronsDataCleaner.version", "kind": "variable", "doc": "<p></p>\n", "default_value": "1300"}, {"fullname": "microns_datacleaner.MicronsDataCleaner.data_storage", "modulename": "microns_datacleaner", "qualname": "MicronsDataCleaner.data_storage", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "microns_datacleaner.MicronsDataCleaner.download_functional_fits", "modulename": "microns_datacleaner", "qualname": "MicronsDataCleaner.download_functional_fits", "kind": "function", "doc": "<p>Downloads functional tuning curves and fits from Zenodo.\nThis convenience method downloads a pre-processed data file containing\nfunctional tuning curves and their fits. The data is hosted on Zenodo\nand has been specifically prepared for use with this package. The method\nhandles the creation of the destination folder before initiating the download.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<ul>\n<li><p><strong>foldername : <em>str, optional</em></strong></p>\n\n<p>The name of the subfolder within the main data directory where the\ndata will be saved, by default \"functional\". If this folder does\nnot exist, it will be created.</p></li>\n</ul>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<ul>\n<li><p><strong>None.</strong></p>\n\n<p>This method does not return a value. It saves the downloaded data to\na file named 'tuning_curves_fitted_v1.csv' inside the specified folder.</p></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">foldername</span><span class=\"o\">=</span><span class=\"s1\">&#39;functional&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "microns_datacleaner.MicronsDataCleaner.get_table_list", "modulename": "microns_datacleaner", "qualname": "MicronsDataCleaner.get_table_list", "kind": "function", "doc": "<p>Retrieves a list of all available tables for the current version.\nThis method queries the CAVEclient to get the names of all tables\navailable in the currently configured materialization version.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>None.\n</code></pre>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>list[str]\n    A list of strings, where each string is the name of an available\n    table in the dataset.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "microns_datacleaner.MicronsDataCleaner.read_table", "modulename": "microns_datacleaner", "qualname": "MicronsDataCleaner.read_table", "kind": "function", "doc": "<p>Reads a specified table from a local CSV file into a pandas DataFrame.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>table_name: str\n    The name of the table to read.\n</code></pre>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>pandas.DataFrame\n    A DataFrame containing the data from the specified CSV file.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">table_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "microns_datacleaner.MicronsDataCleaner.download_nucleus_data", "modulename": "microns_datacleaner", "qualname": "MicronsDataCleaner.download_nucleus_data", "kind": "function", "doc": "<p>Downloads all nucleus-related tables based on the initial configuration.\nThe specific tables downloaded depend on the <code>download_policy</code> chosen at initialization.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>None.\n</code></pre>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>None.\n    This method does not return a value. It saves the downloaded tables\n    as CSV files in the `raw` data directory.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "microns_datacleaner.MicronsDataCleaner.download_tables", "modulename": "microns_datacleaner", "qualname": "MicronsDataCleaner.download_tables", "kind": "function", "doc": "<p>Downloads a user-specified list of tables.\nThis method allows for downloading an arbitrary list of tables from the\ndatabase, in addition to those specified by the download policy during\ninitialization.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>table_names: list[str]\n    A list containing the exact names of the tables to be downloaded.\n</code></pre>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>None.\n    This method does not return a value. It saves the downloaded tables\n    as CSV files in the `raw` data directory.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">table_names</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "microns_datacleaner.MicronsDataCleaner.download_synapse_data", "modulename": "microns_datacleaner", "qualname": "MicronsDataCleaner.download_synapse_data", "kind": "function", "doc": "<p>Downloads synaptic connections between specified sets of neurons.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>presynaptic_set: numpy.ndarray\n    A 1D NumPy array of unique `root_ids` for the presynaptic neurons.\npostsynaptic_set: numpy.ndarray\n    A 1D NumPy array of unique `root_ids` for the postsynaptic neurons.\nneurs_per_steps: int, optional\n    The number of postsynaptic neurons to query per batch, by default 500.\n    This is crucial for managing API query size and preventing crashes.\nstart_index: int, optional\n    The batch index from which to start or resume the download, by default 0.\n    Set this to continue an interrupted download.\nmax_retries: int, optional\n    The maximum number of times to retry a failed API query before\n    raising an error, by default 10.\ndelay: int, optional\n    The number of seconds to wait between retries if an API error occurs,\n    by default 5.\ndrop_synapses_duplicates: bool, optional\n    If True (default), all synapses between any two neurons are merged into a\n    single entry, with `synapse_size` being the sum of individual sizes.\n    If False, each synapse is kept as a separate record.\n</code></pre>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>None.\n    This method does not return a value. It saves the downloaded synapse\n    tables as a series of CSV files in the `raw/synapses` directory.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">presynaptic_set</span>,</span><span class=\"param\">\t<span class=\"n\">postsynaptic_set</span>,</span><span class=\"param\">\t<span class=\"n\">neurs_per_steps</span><span class=\"o\">=</span><span class=\"mi\">500</span>,</span><span class=\"param\">\t<span class=\"n\">start_index</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">max_retries</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">delay</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">drop_synapses_duplicates</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "microns_datacleaner.MicronsDataCleaner.merge_synapses", "modulename": "microns_datacleaner", "qualname": "MicronsDataCleaner.merge_synapses", "kind": "function", "doc": "<p>Merges downloaded synapse data batches into a single CSV file.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>syn_table_name: str\n    The name for the output file that will contain the merged synapse data.\n</code></pre>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>None.\n    This method does not return a value. It saves the merged table to a file.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">syn_table_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "microns_datacleaner.MicronsDataCleaner.merge_table", "modulename": "microns_datacleaner", "qualname": "MicronsDataCleaner.merge_table", "kind": "function", "doc": "<p>Merges new columns from a source table into the main unit table.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>unit_table: pandas.DataFrame\n    The primary DataFrame to which new columns will be added.\nnew_table: pandas.DataFrame\n    The source DataFrame from which to pull the new columns.\ncolumns: list[str] or None\n    A list of column names from `new_table` to merge into `unit_table`.\n    If None, all columns from `new_table` (except the join keys) are used.\nmethod: str \n    How the tables will be compared to each other. If 'nucleus_id' (default), the target_id \n    is matched to the nucleus_id. If functional, the session, scan and unit_id are compared. \n    If 'pt_root_id', merge by 'pt_root_id'. This last option is not adviced, unless is the only index available.\nhow: str\n    Equivalent to Panda's how argument for the merge function. Only 'inner' or 'left' are allowed, since the \n    new columns are always added into the nucleus table.\n</code></pre>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>pandas.DataFrame\n    The merged DataFrame with the newly added columns.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">unit_table</span>,</span><span class=\"param\">\t<span class=\"n\">new_table</span>,</span><span class=\"param\">\t<span class=\"n\">columns</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">&#39;nucleus_id&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">how</span><span class=\"o\">=</span><span class=\"s1\">&#39;left&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "microns_datacleaner.MicronsDataCleaner.process_nucleus_data", "modulename": "microns_datacleaner", "qualname": "MicronsDataCleaner.process_nucleus_data", "kind": "function", "doc": "<p>Processes downloaded data to generate a final, annotated unit table.\nIt reads all previously downloaded nucleus-related tables (cell type,\nproofreading, brain area, etc.), merges them sequentially, transforms\ncoordinates, performs cortical layer segmentation, and optionally\nintegrates functional data based on the chosen strategy.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>functional_data: {'none', 'match', 'all', 'best_only'}, optional\n    Specifies how to integrate functional data, by default 'none'.\n    - 'none': No functional data is added.\n    - 'match': Adds columns (`session`, `scan_idx`, `functional_unit_id`)\n      to allow matching units with their corresponding functional scans.\n    - 'all': Merges functional data from all available scans for each unit,\n      potentially resulting in multiple rows per unit.\n    - 'best_only': Merges data only from the scan with the highest\n      performance metric (`cc_abs`) for each unit.\n</code></pre>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>nucleus_merged: pandas.DataFrame\n    The primary, processed unit table with all annotations, including\n    cell type, proofreading status, brain area, cortical layer, and\n    optionally functional properties.\nsegments: pandas.DataFrame\n    A DataFrame detailing the calculated cortical layer segments,\n    including their start and end coordinates.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">functional_data</span><span class=\"o\">=</span><span class=\"s1\">&#39;none&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "microns_datacleaner.filters", "modulename": "microns_datacleaner.filters", "kind": "module", "doc": "<h1 id=\"filters-subpackage\">Filters subpackage</h1>\n\n<p>The filters subpackage helps to query the units and synapse tables. The tables are just Pandas Dataframes, so it is always possible to <code>.query</code> them.\nHowever, often it is necessary to query for several aspects at once, which is inconvenient, especially for the synapses.\nThe <code>filters</code> package helps to reduce the effort for the most common operations. \nAs stated in the Quick Start, the three most important functions are <code>filter_neurons</code>, <code>filter_connections</code> and <code>synapses_by_id</code>. \nThere are several examples in the <code>basic_notebook</code>.  The API reference below contains detailed information about the arguments of these functions. </p>\n\n<blockquote>\n  <p>It is important to notice that the filters act only on the predefined columns of the unit table, but not on custom columns added from the other tables. In these cases, your best bet is to <code>.query</code> directly.</p>\n</blockquote>\n\n<p>Please read the API below for more information in individual functions.</p>\n"}, {"fullname": "microns_datacleaner.filters.filter_neurons", "modulename": "microns_datacleaner.filters", "qualname": "filter_neurons", "kind": "function", "doc": "<p>Filters neurons by several common characteristics simultaneously.\nThis function allows filtering of neurons based on multiple criteria including\nlayer, brain area, cell type, functional tuning properties, and proofreading\nstatus. Parameters left as None will not be used for filtering, allowing\nflexible combinations of filtering criteria.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>units: pandas.DataFrame\n    The neuron properties DataFrame containing all neuron data to be filtered.\nlayer: str or list, optional\n    The layer(s) to filter for. Can be a single layer name as string or\n    multiple layers as a list of strings, by default None.\nbrain_area: str or list, optional\n    The brain area(s) to filter for. Can be a single area name as string\n    or multiple areas as a list of strings, by default None.\ncell_type: str or list, optional\n    The cell type(s) to filter for. Can be a single cell type as string\n    or multiple cell types as a list of strings, by default None.\ntuning: str, optional\n    Functional tuning filter criteria. Use 'matched' to filter for\n    functionally matched neurons, 'tuned' for neurons with tuning\n    information, or 'untuned' for neurons without tuning, by default None.\nproofread: str, optional\n    Proofreading level filter. Options include 'non' (no proofreading),\n    'clean' (some proofreading), 'extended' (best proofreading). Note that\n    'clean' includes both clean and extended neurons. Use prefixes 'ax_'\n    or 'dn_' to target axons or dendrites respectively (e.g., 'dn_non',\n    'ax_clean'), by default None.\n</code></pre>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>pandas.DataFrame\n    A filtered DataFrame containing only the neurons that satisfy all\n    specified filtering criteria.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">units</span>,</span><span class=\"param\">\t<span class=\"n\">layer</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">brain_area</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cell_type</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">tuning</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">proofread</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "microns_datacleaner.filters.filter_connections", "modulename": "microns_datacleaner.filters", "qualname": "filter_connections", "kind": "function", "doc": "<p>Filters synaptic connections by applying separate criteria to presynaptic and postsynaptic neurons.\nThis convenience function allows for independent filtering of presynaptic and postsynaptic neurons\nusing different criteria, then returns all connections between the filtered neuron populations. \nThe function internally calls filter_neurons for each synaptic partner and synapses_by_id to extract\nmatching connections.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>units: pandas.DataFrame\n    The neuron properties DataFrame containing all neuron metadata.\nconnections: pandas.DataFrame\n    The synaptic connections DataFrame containing connectivity information.\nlayer: list of length 2, optional\n    Filtering criteria for cortical layers. First element applies to\n    presynaptic neurons, second to postsynaptic neurons, by default [None, None].\ntuning: list of length 2, optional\n    Filtering criteria for functional tuning properties. First element\n    applies to presynaptic neurons, second to postsynaptic neurons, by default [None, None].\nbrain_area : list of length 2, optional\n    Filtering criteria for brain areas. First element applies to\n    presynaptic neurons, second to postsynaptic neurons. Each element\n    follows the same format as the brain_area parameter in filter_neurons\n    (str or list of str), by default [None, None].\ncell_type: list of length 2, optional\n    Filtering criteria for cell types. First element applies to\n    presynaptic neurons, second to postsynaptic neurons, by default [None, None].\nproofread: list of length 2, optional\n    Filtering criteria for proofreading levels. First element applies to\n    presynaptic neurons, second to postsynaptic neurons,\n    by default [None, None].\n</code></pre>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>pandas.DataFrame\n    A filtered connections DataFrame containing only synapses between\n    neurons that satisfy the specified presynaptic and postsynaptic\n    filtering criteria.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">units</span>,</span><span class=\"param\">\t<span class=\"n\">connections</span>,</span><span class=\"param\">\t<span class=\"n\">layer</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">tuning</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">brain_area</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">cell_type</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">proofread</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "microns_datacleaner.filters.synapses_by_id", "modulename": "microns_datacleaner.filters", "qualname": "synapses_by_id", "kind": "function", "doc": "<p>This function extracts synapses from a connectivity DataFrame based on specified\npresynaptic and postsynaptic neuron IDs. The filtering behavior can be customized\nto return synapses that match either presynaptic OR postsynaptic criteria, or\nonly those that match BOTH criteria simultaneously.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>connections: pandas.DataFrame\n    The connectivity DataFrame containing synaptic connection information\n    with columns for presynaptic and postsynaptic neuron IDs.\npre_ids: array-like, optional\n    Array of presynaptic neuron IDs to filter for. If None, presynaptic\n    filtering is not applied, by default None.\npost_ids: array-like, optional\n    Array of postsynaptic neuron IDs to filter for. If None, postsynaptic\n    filtering is not applied, by default None.\nboth: bool, optional\n    Controls filtering behavior when both pre_ids and post_ids are specified.\n    If True, returns only synapses where both presynaptic and postsynaptic\n    IDs match the specified criteria (intersection). If False, returns\n    synapses where either presynaptic OR postsynaptic IDs match (union),\n    by default True.\n</code></pre>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>pandas.DataFrame\n    A filtered DataFrame containing only the synapses that match the\n    specified ID criteria.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">connections</span>, </span><span class=\"param\"><span class=\"n\">pre_ids</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">post_ids</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">both</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "microns_datacleaner.filters.remove_autapses", "modulename": "microns_datacleaner.filters", "qualname": "remove_autapses", "kind": "function", "doc": "<p>Removes autapses from the synaptic connections table.</p>\n\n<p>This function filters out autaptic connections (synapses where a neuron\nconnects to itself) from the provided connections DataFrame.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>connections: pandas.DataFrame\n    The synaptic connections DataFrame containing connectivity information\n    with columns for presynaptic and postsynaptic neuron IDs.\n</code></pre>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>pandas.DataFrame\n    A new DataFrame containing all synaptic connections except autapses.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">connections</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "microns_datacleaner.filters.connections_to", "modulename": "microns_datacleaner.filters", "qualname": "connections_to", "kind": "function", "doc": "<p>Retrieves presynaptic neurons that connect to a specified postsynaptic neuron.\nThis function identifies all presynaptic neurons that form synaptic connections\nwith the specified postsynaptic neuron ID.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>post_id: int or str\n    The ID of the postsynaptic neuron for which to find presynaptic\n    partners.\nconnections: pandas.DataFrame\n    The synaptic connections DataFrame containing connectivity information\n    with columns for presynaptic and postsynaptic neuron IDs.\nonly_id: bool, optional\n    Controls the output format. If True, returns only the presynaptic\n    neuron IDs. If False, returns the complete connection\n    records as a DataFrame, by default True.\n</code></pre>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>pandas.DataFrame\n    If only_id is True, returns the presynaptic neuron IDs. If only_id is False,\n    returns a DataFrame with all connection records where the specified neuron is postsynaptic.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">post_id</span>, </span><span class=\"param\"><span class=\"n\">connections</span>, </span><span class=\"param\"><span class=\"n\">only_id</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "microns_datacleaner.filters.connections_from", "modulename": "microns_datacleaner.filters", "qualname": "connections_from", "kind": "function", "doc": "<p>Retrieves postsynaptic neurons that receive connections from a specified presynaptic neuron.\nThis function identifies all postsynaptic neurons that receive synaptic connections\nfrom the specified presynaptic neuron ID.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>pre_id: int or str\n    The ID of the presynaptic neuron for which to find postsynaptic\n    targets.\nconnections: pandas.DataFrame\n    The synaptic connections DataFrame containing connectivity information\n    with columns for presynaptic and postsynaptic neuron IDs.\nonly_id: bool, optional\n    Controls the output format. If True, returns only the postsynaptic\n    neuron IDs. If False, returns the complete connection\n    records as a DataFrame, by default True.\n</code></pre>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>pandas.DataFrame\n    If only_id is True, returns the postsynaptic neuron IDs. If only_id is False,\n    returns a DataFrame with all connection records where the specified neuron is presynaptic.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pre_id</span>, </span><span class=\"param\"><span class=\"n\">connections</span>, </span><span class=\"param\"><span class=\"n\">only_id</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "microns_datacleaner.remapper", "modulename": "microns_datacleaner.remapper", "kind": "module", "doc": "<h1 id=\"remapper-subpackage\">Remapper subpackage</h1>\n\n<p>The remapper subpackage is particularly useful to work with functional data. The package distributes the average rates of every neuron in the functional\ndataset to each direction (and orientation), i.e. the tuning curves. These can be used to estimate input current to neurons.</p>\n\n<p>The most efficient way to perform this computation is to compute the adjacency matrix <code>msp</code> by the vector of rates <code>rates</code> for functionally matched neurons.<br />\nHowever, most of the informatino is Pandas DataFrames, which complicate this operation. </p>\n\n<p>The remapper package helps to create the adjacency matrix of the data, by substituting all the <code>pt_root_id</code> identifiers by numbers from \n<code>0</code> to <code>N-1</code>, being <code>N</code> the number of selected functionally matched neurons. The remapped ids are sorted in the same order as the unit table\nprovided. In this way, if a row in the remapped table contains <code>i j s</code> the current input to <code>j</code> from <code>i</code> is <code>s * rates[i]</code>.</p>\n\n<p>Assume <code>units_func</code> is a unit table with functionally matched neurons and <code>syn_func</code> contains synapses among them. Then,</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">scipy.sparse</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">sp</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">microns_dataclear.remapper</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">rem</span>\n\n<span class=\"c1\">#Obtain the matrix of rates (one vector for each orientation)</span>\n<span class=\"n\">rates</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">(</span><span class=\"n\">units_func</span><span class=\"p\">[</span><span class=\"s1\">&#39;rate_ori&#39;</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">))</span>\n\n<span class=\"c1\">#Remap indices and build adjacency matrix</span>\n<span class=\"n\">units_func</span><span class=\"p\">,</span> <span class=\"n\">syn_func_remapped</span> <span class=\"o\">=</span> <span class=\"n\">rem</span><span class=\"o\">.</span><span class=\"n\">remap_all_tables</span><span class=\"p\">(</span><span class=\"n\">units_func</span><span class=\"p\">,</span> <span class=\"n\">syn_func</span><span class=\"p\">)</span>\n<span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">syn_func_remapped</span><span class=\"o\">.</span><span class=\"n\">values</span>\n<span class=\"n\">msp</span> <span class=\"o\">=</span> <span class=\"n\">sp</span><span class=\"o\">.</span><span class=\"n\">csr_matrix</span><span class=\"p\">((</span><span class=\"n\">m</span><span class=\"p\">[:,</span><span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">[:,</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">m</span><span class=\"p\">[:,</span><span class=\"mi\">1</span><span class=\"p\">])),</span> <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">units_func</span><span class=\"p\">),</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">units_func</span><span class=\"p\">)))</span> \n\n<span class=\"c1\">#Compute input current to the neurons!</span>\n<span class=\"n\">currents</span> <span class=\"o\">=</span> <span class=\"n\">msp</span> <span class=\"o\">@</span> <span class=\"n\">rates</span>\n<span class=\"n\">currents</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>A fully developed example is present in the <code>basic_tutorial</code>.</p>\n"}, {"fullname": "microns_datacleaner.remapper.remap_all_tables", "modulename": "microns_datacleaner.remapper", "qualname": "remap_all_tables", "kind": "function", "doc": "<p>Remaps all neuron and connection tables to use sequential integer IDs.\nThis convenience function performs a complete remapping of both neuron and\nconnection tables from original ID systems to sequential integer indexing\nstarting from 0.</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<pre><code>units: pandas.DataFrame\n    The neuron properties DataFrame containing neuron metadata with\n    original 'pt_root_id' identifiers.\nconnections: pandas.DataFrame\n    The synaptic connections DataFrame with 'pre_pt_root_id' and\n    'post_pt_root_id' columns containing original neuron IDs.\n</code></pre>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<pre><code>tuple of pandas.DataFrames\n    new_units: DataFrame with both original 'pt_root_id' and remapped\n        'id_remapped' columns.\n    new_connections: DataFrame with remapped 'pre_id' and 'post_id'\n        columns using sequential integer IDs.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">units</span>, </span><span class=\"param\"><span class=\"n\">connections</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();